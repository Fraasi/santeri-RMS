{"version":3,"sources":["Input/index.js","App.js","serviceWorker.js","index.js"],"names":["qmean","require","Input","inputRef","useRef","dropRef","useState","name","lastModified","size","type","file","setFile","mean1","mean2","means","setMeans","qMean","setQmean","calculating","setCalculating","useEffect","dragEnterOver","e","stopPropagation","preventDefault","current","addEventListener","files","dataTransfer","readFiles","item","reader","FileReader","onloadend","arrBuffer","a","async","data","blob","target","result","audioCtx","AudioContext","decodeAudioData","then","decodedData","getChannelData","int32Arr","qrsm","f32a","results","i","length","r","Meyda","extract","slice","push","sum","reduce","acc","num","mean","onerror","err","Error","readAsArrayBuffer","number","style","display","ref","accept","multiple","onChange","id","onClick","click","className","Date","toLocaleString","toFixed","href","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.479fc1ca.chunk.js","sourcesContent":["import React, { useState, useRef, useEffect } from 'react'\nimport Meyda from 'meyda'\nimport './styles.css'\n// no need for browserify, create-react-app handles requires also\nvar qmean = require('compute-qmean')\n\n\nconst Input = () => {\n  const BUFFER_OFFSET = 128 //1024 //4096 // 512\n  const inputRef = useRef()\n  const dropRef = useRef()\n  const [file, setFile] = useState({\n    name: '',\n    lastModified: 0,\n    size: 0,\n    type: '',\n  })\n  const [means, setMeans] = useState({ mean1: 0, mean2: 0 })\n  const [qMean, setQmean] = useState(0)\n  const [calculating, setCalculating] = useState(false)\n\n  useEffect(() => {\n    function drop(e) {\n      e.stopPropagation();\n      e.preventDefault();\n      const dt = e.dataTransfer;\n      const files = dt.files;\n      readFiles(files);\n    }\n    function dragEnterOver(e) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n\n    dropRef.current.addEventListener(\"dragenter\", dragEnterOver, false);\n    dropRef.current.addEventListener(\"dragover\", dragEnterOver, false);\n    dropRef.current.addEventListener(\"drop\", drop, false);\n  }, [])\n\n\n  const readFiles = (files) => {\n    setCalculating(true)\n    // console.log('files:', files, inputRef.current.files.item(0))\n    const hasFiles = files?.item?.(0)\n    // console.log('hasFiles:', hasFiles)\n    const file = hasFiles ? files.item(0) : inputRef.current.files.item(0)\n    // const file = inputRef.current.files.item(0)\n\n    setFile(file)\n    const reader = new FileReader()\n    reader.onloadend = async (arrBuffer) => {\n      // console.log('arrBuffer:', arrBuffer.target.result)\n      var data = {\n        blob: arrBuffer.target.result,\n        name: file.name,\n      }\n\n      const audioCtx = new AudioContext()\n      const int32Arr = await audioCtx.decodeAudioData(data.blob)\n        .then(decodedData => {\n          // console.log('decodedData:', decodedData)\n          return decodedData.getChannelData(0)\n        })\n      //   .catch(err) {\n      //     throw new Error(err)\n      // }\n\n      // console.log('int32Arr:', int32Arr)\n\n      // const f32a = new Int32Array(decodedData)\n      const f32a = int32Arr\n      const qrsm = qmean(f32a)\n      // console.log('qrsm:', qrsm)\n      setQmean(qrsm)\n      const results = []\n\n      for (let i = 0; i < f32a.length - BUFFER_OFFSET; i += BUFFER_OFFSET) {\n        const r = Meyda.extract('rms', f32a.slice(i, i + BUFFER_OFFSET))\n        // console.log('r:', r)\n        results.push(r)\n      }\n      const sum = results.reduce((acc, num) => {\n        return acc + num\n      }, 0)\n\n      const mean = sum / results.length\n      const mean2 = sum / (results.length - BUFFER_OFFSET)\n      setMeans({ mean1: mean, mean2: mean2 })\n      setCalculating(false)\n    }\n    reader.onerror = (err) => { throw new Error(err) }\n    if (file) reader.readAsArrayBuffer(file)\n  }\n\n  function returnFileSize(number) {\n    if (number < 1024) {\n      return number + ' bytes';\n    } else if (number > 1024 && number < 1048576) {\n      return (number / 1024).toFixed(1) + ' KB';\n    } else if (number > 1048576) {\n      return (number / 1048576).toFixed(1) + ' MB';\n    }\n  }\n\n  const openFileInput = () => {\n    inputRef.current.click()\n  }\n\n  const { name, lastModified, size, type } = file\n  return (\n    <div>\n      <input\n        style={{ display: 'none' }}\n        ref={inputRef}\n        type=\"file\"\n        name=\"file\"\n        accept=\"audio/*\"\n        multiple={false}\n        onChange={readFiles}\n      />\n      <button id=\"fileSelect\" onClick={openFileInput}>Valitse äänitiedosto</button>\n      {/* TODO: handle file = null */}\n      <p className=\"fileattrs\" ref={dropRef}>\n        filename: {name} <br />\n        lastModifiedDate: {new Date(lastModified).toLocaleString()}<br />\n        size: {returnFileSize(size)}<br />\n        type: {type}\n      </p>\n      {calculating && <p className=\"calculating\">Lasketaan matikkaa<span className=\"calculating-css\"></span></p>}\n      <p className=\"means\">\n        <a href=\"https://github.com/meyda/meyda\">meyda</a> rms: {means.mean1} <br />\n        <a href=\"https://github.com/meyda/meyda\">meyda</a> rms (BUFFER_OFFSET {BUFFER_OFFSET}): {means.mean2} <br />\n        <a href=\"https://github.com/compute-io/qmean\">qMean rms:</a> {qMean}\n      </p>\n\n    </div >\n  )\n}\n\nexport default Input\n","import React from 'react';\nimport Input from './Input/index.js'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n<Input />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}